// Модули

// Начиная с версии ECMAScript 2015 в JavaScript появились модули.
// TypeScript также поддерживает работу с модулями.
// Но в браузерах нативная поддержка модулей ещё не реализована.

// В TypeScript, как и в ECMAScript 2015, любой файл, содержащий import или export верхнего уровня, считается модулем.
// Отношения между модулями осуществляются путём импорта и экспорта на уровне файла.

// Файл без каких-либо объявлений верхнего уровня import или export рассматривается как сценарий,
// содержимое которого доступно в глобальной области (и, следовательно, также и для модулей).

// Модули выполняются не в глобальной, а в своей собственной области видимости.
// Это означает, что переменные, функции, классы, объекты и т.д., объявленные в модуле, не видны вне модуля,
// за исключением тех случаев, когда они явно экспортированы с использованием ключевого слова export.

// Модули выделяются в отдельные файлы, что позволяет сделать код приложения более ясным и чистым, и в то же время позволяет использовать модули в других приложениях.
// Модули подключаются в приложение не посредством тега <script>, а с помощью загрузчика модулей (например, загрузчик CommonJS для Node.js и require.js для веб-приложений).

// Все модули имеют определенный формат и относятся к определенной системе. Можно использовать следующие системы модулей:
// AMD (Asynchronys Module Defenition), CommonJS, UMD (Universal Module Defenition), System, ES 2015.
// В зависимости от цели модуля, указанной во время компиляции, компилятор сгенерирует соответствующий код для Node.js (CommonJS), require.js (AMD), (UMD), SystemJS 
// или собственных модулей ECMAScript 2015 (ES6).

// 1. Определение модуля и экспорт - ключевое слово export:
// export класc, интерфейс, функция, объект;

// a. Экспорт объявления (Exporting a declaration)

// определение и экспорт интерфейса, класса и функции в модуле devices.ts
// export interface Device { /*...*/ }
// export class Phone implements Device { /*...*/ }
// export function call(phone: Phone): void { /*...*/ }

// или

// b. Экспорт определения (Export statements)

// interface Device { /*...*/ }
// class Phone implements Device { /*...*/ }
// function call(phone: Phone): void { /*...*/ }

// определение псевдонима для функции сall с помощью ключевого слова as
// этот псевдоним (имя) дальше можно использовать при импорте
// export { Device, Phone, сall as сallPhone };

// или

// c. Ре-экспорт (Re-exports), модули расширяют другие модули
// Ре-экспорт не выполняет локального импорта и не создаёт локальную переменную

// export { A as B } from "module";
// export * from "module";  // ре-экспортировать сразу все операторы экспорта

// 2. Экспорт по умолчанию - ключевое слово default export:
// это определение типа, который будет импортироваться из модуля по умолчанию;
// в модуле может быть только одна такая инструкция

// определение и экспорт класса в модуле smartwatch.ts
// export default class SmartWatch { /*...*/ }

// импорт класса из модуля smartwatch.ts

import SmartWatch from "./smartwatch";
let watch: SmartWatch = new SmartWatch("Apple Watch S5");
console.log(watch.model);

// 3. Импорт модуля - оператор import:
// import класc, интерфейс, функция, объект from "путь к модулю"
// "путь к модулю" - название файла без расширения:
// "./devices" - модуль devices.ts в той же директории;
// "./lib/devices" - модуль devices.ts в поддиректории lib

// импорт класса и функции из модуля devices.ts

import { Phone, call } from "./devices";
let iphone: Phone = new Phone("iPhone 12");
call(iphone);

// с помощью оператора as можно указать псевдоним

import { Phone as Phone1, call as makeCall } from "./devices";
let iphone1: Phone1 = new Phone1("iPhone 12");
makeCall(iphone1);

// можно импортировать сразу весь модуль под псевдонимом

import * as dev from "./devices"; // псевдоним dev
let iphone2: dev.Phone = new dev.Phone("iPhone 12");
dev.call(iphone2);
